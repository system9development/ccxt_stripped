# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.base.exchange import Exchange
import json
from ccxt.base.errors import ExchangeError
from ccxt.base.errors import ArgumentsRequired
from ccxt.base.errors import BadSymbol
from ccxt.base.errors import InvalidNonce
from ccxt.base.decimal_to_precision import TRUNCATE
from ccxt.base.decimal_to_precision import DECIMAL_PLACES
from ccxt.base.precise import Precise


class deepwaters(Exchange):

    def describe(self):
        return self.deep_extend(super(deepwaters, self).describe(), {
            'id': 'deepwaters',
            'name': 'Deepwaters',
            'countries': ['US'],
            'rateLimit': 5,
            'certified': False,
            'version': 'v1',
            'has': {
                'CORS': None,
                'spot': True,
                'margin': False,
                'swap': False,
                'future': False,
                'option': False,
                'cancelAllOrders': True,
                'cancelOrder': True,
                'createOrder': True,
                'createStopLimitOrder': False,
                'createStopMarketOrder': False,
                'createStopOrder': False,
                'fetchBalance': True,
                'fetchBidsAsks': True,
                'fetchBorrowRate': False,
                'fetchBorrowRateHistories': False,
                'fetchBorrowRateHistory': False,
                'fetchBorrowRates': False,
                'fetchBorrowRatesPerSymbol': False,
                'fetchCanceledOrders': True,
                'fetchClosedOrders': True,
                'fetchCurrencies': True,
                'fetchDepositAddress': False,
                'fetchDeposits': True,
                'fetchMarginMode': False,
                'fetchMarkets': True,
                'fetchMyTrades': True,
                'fetchOHLCV': False,
                'fetchOpenOrders': True,
                'fetchOrder': True,
                'fetchOrderBook': True,
                'fetchOrders': True,
                'fetchPositionMode': False,
                'fetchStatus': False,
                'fetchTicker': True,
                'fetchTickers': True,
                'fetchTime': True,
                'fetchTrades': False,
                'fetchTradingFee': False,
                'fetchTradingFees': False,
                'fetchTransactionFees': False,
                'fetchTransactions': False,
                'fetchTransfers': False,
                'fetchWithdrawals': True,
                'transfer': False,
                'withdraw': False,
            },
            'timeframes': None,
            'urls': {
                'test': {
                    'public': 'https://testnet.api.deepwaters.xyz/rest/v1',
                    'private': 'https://testnet.api.deepwaters.xyz/rest/v1',
                },
                'api': {
                    'public': 'https://api.deepwaters.xyz/rest/v1',
                    'private': 'https://api.deepwaters.xyz/rest/v1',
                },
                'www': 'https://deepwaters.xyz',
                'referral': '',
                'doc': [
                    'https://rest.docs.api.deepwaters.xyz/',
                ],
            },
            'fees': {
                'trading': {
                    'tierBased': False,
                    'percentage': True,
                    'maker': 0.001,
                    'taker': 0.0015,
                    'feeSide': 'get',
                },
            },
            'requiredCredentials': {
                'apiKey': True,
                'secret': True,
            },
            'api': {
                'public': {
                    'get': [
                        'assets',
                        'pairs',
                        'pairs/{pair}/orderbook',
                        'time',
                    ],
                },
                'private': {
                    'get': [
                        'customer',
                        'customer/api-key-status',
                        'orders',
                        'orders/by-venue-order-id/{id}',
                        'orders/by-customer-object-id/{id}',
                        'trades',
                    ],
                    'post': [
                        'orders',
                    ],
                    'delete': [
                        'orders',
                        'orders/by-customer-object-id/{id}',
                        'orders/by-venue-order-id/{id}',
                    ],
                },
            },
            'precisionMode': DECIMAL_PLACES,
        })

    def fetch_bids_asks(self, symbols=None, params={}):
        """
        fetches the bid and ask price and volume for multiple markets
        :param [str]|None symbols: unified symbols of the markets to fetch the bids and asks for, all markets are returned if not assigned
        :param dict params: extra parameters specific to the deepwaters api endpoint
        :returns dict: a dictionary of `ticker structures <https://docs.ccxt.com/en/latest/manual.html#ticker-structure>`
        """
        return self.fetch_tickers(symbols, params)

    def fetch_ticker(self, symbol, params={}):
        """
        fetches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        :param str symbol: unified symbol of the market to fetch the ticker for
        :param dict params: extra parameters specific to the deepwaters api endpoint
        :returns dict: a `ticker structure <https://docs.ccxt.com/en/latest/manual.html#ticker-structure>`
        """
        if not symbol:
            raise ArgumentsRequired('symbol must be provided to deepwaters#fetchTicket()')
        tickers = self.fetch_tickers([symbol])
        if len(tickers) == 0:
            raise BadSymbol('Symbol not found. Is it available in  deepwaters#fetchMarkets()?')
        return tickers[symbol]

    def fetch_tickers(self, symbols=None, params={}):
        """
        fetches price tickers for multiple markets, statistical calculations with the information calculated over the past 24 hours each market
        :param [str]|None symbols: unified symbols of the markets to fetch the ticker for, all market tickers are returned if not assigned
        :param dict params: extra parameters specific to the deepwaters api endpoint
        :returns dict: a dictionary of `ticker structures <https://docs.ccxt.com/en/latest/manual.html#ticker-structure>`
        """
        self.load_markets()
        symbols = self.market_symbols(symbols)
        response = self.publicGetPairs()
        success = self.safe_value(response, 'success', False)
        if not success:
            return self.handle_error(response)
        markets = self.safe_value(response, 'result', {})
        tickers = []
        for i in range(0, len(markets)):
            # {
            #     baseAssetRootSymbol: 'AVAX',
            #     quoteAssetRootSymbol: 'USDC',
            #     baseAssetParentSymbol: 'WAVAX.DW',
            #     quoteAssetParentSymbol: 'USDC.DW',
            #     baseAssetID: 'WAVAX.AVALANCHE_FUJI.43113.TESTNET.PROD',
            #     quoteAssetID: 'USDC.AVALANCHE_FUJI.43113.TESTNET.PROD',
            #     name: 'WAVAX.AVALANCHE_FUJI.43113.TESTNET.PROD-USDC.AVALANCHE_FUJI.43113.TESTNET.PROD',
            #     baseAssetIncrementSize: '.01',
            #     baseAssetIncrementPrecision: '2',
            #     quoteAssetIncrementSize: '.001',
            #     quoteAssetIncrementPrecision: '3',
            #     createdAtMicros: '1677695274781348',
            #     quotedAtMicros: '1677838210968536',
            #     ask: '16.418',
            #     bid: '16.396'
            # }
            market = markets[i]
            base = self.safe_value(market, 'baseAssetRootSymbol')
            quote = self.safe_value(market, 'quoteAssetRootSymbol')
            symbol = base + '/' + quote
            quotedAtMicros = self.safe_value(market, 'quotedAtMicros')
            timestamp = self.parse_number(Precise.string_div(quotedAtMicros, '1000', 0))
            datetime = self.iso8601(timestamp)
            ask = self.safe_number(market, 'ask')
            bid = self.safe_number(market, 'bid')
            tickers.append(self.safe_ticker({
                'symbol': symbol,
                'timestamp': timestamp,
                'datetime': datetime,
                'ask': ask,
                'bid': bid,
                'info': market,
            }))
        return self.filter_by_array(tickers, 'symbol', symbols)

    def fetch_markets(self, params={}):
        """
        fetches market data from deepwaters
        :returns [dict]: an array of market data objects
        """
        response = self.publicGetPairs()
        success = self.safe_value(response, 'success', False)
        if not success:
            return self.handle_error(response)
        markets = self.safe_value(response, 'result', {})
        result = []
        for i in range(0, len(markets)):
            # {
            #     baseAssetRootSymbol: 'AVAX',
            #     quoteAssetRootSymbol: 'USDC',
            #     baseAssetParentSymbol: 'WAVAX.DW',
            #     quoteAssetParentSymbol: 'USDC.DW',
            #     baseAssetID: 'WAVAX.AVALANCHE_FUJI.43113.TESTNET.PROD',
            #     quoteAssetID: 'USDC.AVALANCHE_FUJI.43113.TESTNET.PROD',
            #     name: 'WAVAX.AVALANCHE_FUJI.43113.TESTNET.PROD-USDC.AVALANCHE_FUJI.43113.TESTNET.PROD',
            #     baseAssetIncrementSize: '.01',
            #     baseAssetIncrementPrecision: '2',
            #     quoteAssetIncrementSize: '.001',
            #     quoteAssetIncrementPrecision: '3',
            #     createdAtMicros: '1677695274781348',
            #     quotedAtMicros: '1677838210968536',
            #     ask: '16.418',
            #     bid: '16.396'
            # }
            market = markets[i]
            id = self.safe_value(market, 'name')
            lowercaseId = self.safe_string_lower(market, 'name')
            base = self.safe_value(market, 'baseAssetRootSymbol')
            quote = self.safe_value(market, 'quoteAssetRootSymbol')
            symbol = base + '/' + quote
            baseId = self.safe_value(market, 'baseAssetID')
            quoteId = self.safe_value(market, 'quoteAssetID')
            baseAssetIncrementPrecision = self.parse_number(self.parse_precision(self.safe_string(market, 'baseAssetIncrementPrecision')))
            quoteAssetIncrementPrecision = self.parse_number(self.parse_precision(self.safe_string(market, 'quoteAssetIncrementPrecision')))
            result.append({
                'id': id,
                'lowercaseId': lowercaseId,
                'symbol': symbol,
                'base': base,
                'quote': quote,
                'settle': None,
                'baseId': baseId,
                'quoteId': quoteId,
                'settleId': None,
                'type': 'spot',
                'spot': True,
                'margin': False,
                'swap': False,
                'future': False,
                'option': False,
                'active': True,
                'contract': False,
                'linear': None,
                'inverse': None,
                'contractSize': None,
                'expiry': None,
                'expiryDatetime': None,
                'strike': None,
                'optionType': None,
                'precision': {
                    'amount': baseAssetIncrementPrecision,
                    'price': quoteAssetIncrementPrecision,
                    'cost': None,
                },
                'limits': {
                    'leverage': {
                        'min': None,
                        'max': None,
                    },
                    'amount': {
                        'min': None,
                        'max': None,
                    },
                    'price': {
                        'min': None,
                        'max': None,
                    },
                    'cost': {
                        'min': None,
                        'max': None,
                    },
                },
                'info': market,
            })
        return result

    def fetch_currencies(self, params={}):
        """
        Fetches all available currencies an exchange and returns an associative dictionary of currencies.
        :param dict params: extra parameters specific to the deepwaters api endpoint
        :returns dict: a dictionary of `currency structure <https://docs.ccxt.com/en/latest/manual.html#currency-structure>`
        """
        response = self.publicGetAssets()
        success = self.safe_value(response, 'success', False)
        if not success:
            return self.handle_error(response)
        currencies = self.safe_value(response, 'result', {})
        result = {}
        for i in range(0, len(currencies)):
            # {
            #     chainID: '5',
            #     chainName: 'GOERLI',
            #     assetAddress: '0x53948de192afe6c531894337799881702115b6b6',
            #     rootSymbol: 'ZRB',
            #     assetID: 'ZRB.GOERLI.5.TESTNET.PROD',
            #     parentSymbol: 'ZRB.DW',
            #     frontEndSymbol: 'ZRB',
            #     name: 'Zorb',
            #     ticker: 'ZRB',
            #     frontEndName: '',
            #     uiDecimals: '5',
            #     databaseDecimals: '25',
            #     contractDecimals: '18',
            #     createdAtMicros: '1677695274753017'
            # }
            currency = currencies[i]
            id = self.safe_string(currency, 'assetID')
            code = self.safe_string(currency, 'rootSymbol')
            name = self.safe_string(currency, 'name')
            precision = self.parse_number(self.parse_precision(self.safe_string(currency, 'uiDecimals')))
            result[code] = {
                'id': id,
                'code': code,
                'name': name,
                'active': True,
                'deposit': True,
                'withdraw': True,
                'fee': None,
                'precision': precision,
                'limits': {
                    'amount': {
                        'min': precision,
                        'max': None,
                    },
                    'withdraw': {
                        'min': None,
                        'max': None,
                    },
                },
                'info': currency,
            }
        return result

    def fetch_order_book(self, symbol, limit=None, params={}):
        """
        fetches information on open orders with bid(buy) and ask(sell) prices, volumes and other data
        :param str symbol: unified symbol of the market to fetch the order book for
        :param int|None limit: the maximum amount of order book entries to return
        :param dict params: extra parameters specific to the deepwaters api endpoint
        :returns dict: A dictionary of `order book structures <https://docs.ccxt.com/en/latest/manual.html#order-book-structure>` indexed by market symbols
        """
        if symbol is None:
            raise ArgumentsRequired(self.id + ' fetchOrderBook() requires a symbol argument')
        self.load_markets()  # self will load only the first time
        market = self.market(symbol)
        request = {
            'pair': market['id'],
        }
        if limit is not None:
            request['depth'] = limit
        response = self.publicGetPairsPairOrderbook(self.extend(request, params))
        success = self.safe_value(response, 'success', False)
        if not success:
            return self.handle_error(response)
        result = self.safe_value(response, 'result', {})
        # {
        #     snapshotAtMicros: '1677844033163585',
        #     bids: [
        #       {depth: '0', price: '320.0100', quantity: '4457663.494'},
        #       {depth: '1', price: '320.0000', quantity: '103676273.148'},
        #       {depth: '2', price: '319.9900', quantity: '1.327'},
        #       {depth: '3', price: '319.8700', quantity: '96.225'},
        #       {depth: '4', price: '319.6600', quantity: '95.303'},
        #       {depth: '5', price: '319.4500', quantity: '103.147'},
        #       {depth: '6', price: '319.2300', quantity: '100.198'},
        #       {depth: '7', price: '319.0200', quantity: '104.780'},
        #       {depth: '8', price: '318.8100', quantity: '102.695'},
        #       {depth: '9', price: '318.5900', quantity: '96.233'}
        #     ],
        #     asks: []
        # }
        snapshotAtMicros = self.safe_string(result, 'snapshotAtMicros', '0')
        timestamp = self.parse_number(Precise.string_div(snapshotAtMicros, '1000', 0))
        return self.parse_order_book(result, symbol, timestamp, 'bids', 'asks', 'price', 'quantity')

    def fetch_balance(self, params={}):
        """
        query for balance and get the amount of funds available for trading or funds locked in orders
        :param dict params: extra parameters specific to the deepwaters api endpoint
        :returns dict: a `balance structure <https://docs.ccxt.com/en/latest/manual.html?#balance-structure>`
        """
        self.load_markets()
        response = self.privateGetCustomer()
        success = self.safe_value(response, 'success', False)
        if not success:
            return self.handle_error(response)
        # {
        #     customerAddress: '0x4db55abc5e7532439501bc6aed40b6281382959a',
        #     nonce: '1',
        #     createdAtMicros: '1677829125843454',
        #     modifiedAtMicros: '1677829125843553',
        #     lastCustomerObjectID: null,
        #     balances: []
        # }
        result = self.safe_value(response, 'result', {})
        balances = self.safe_value(result, 'balances')
        modifiedAtMicros = self.safe_value(result, 'modifiedAtMicros')
        timestamp = self.parse_number(Precise.string_div(modifiedAtMicros, '1000', 0))
        datetime = self.iso8601(timestamp)
        output = {
            'timestamp': timestamp,
            'datetime': datetime,
            'info': result,
            'free': {},
            'used': {},
            'total': {},
        }
        for i in range(0, len(balances)):
            # {
            #     'amount': 'string',
            #     'assetID': 'string',
            #     'serviceDescription': 'string',
            #     'serviceName': 'string'
            # }
            balance = balances[i]
            currencyId = self.safe_value(balance, 'assetID')
            currency = self.safe_value(self.currencies_by_id, currencyId)
            if not currency:
                # self is only needed in sandbox mode, if you get airdrops
                continue
            currencyCode = self.safe_value(currency, 'code')
            if not output[currencyCode]:
                output[currencyCode] = {
                    'used': '0',
                    'free': '0',
                }
                output['used'][currencyCode] = '0'
                output['free'][currencyCode] = '0'
            amount = self.safe_value(balance, 'amount')
            serviceName = self.safe_value(balance, 'serviceName')
            if serviceName == 'accounting.available':
                output[currencyCode]['free'] = amount
                output['free'][currencyCode] = amount
            elif serviceName == 'fee' or serviceName == 'swap.engine':
                used = Precise.string_add(output[currencyCode]['used'], amount)
                output[currencyCode]['used'] = used
                output['used'][currencyCode] = used
        keys = list(output['used'].keys())
        for i in range(0, len(keys)):
            key = keys[i]
            total = Precise.string_add(output['used'][key], output['free'][key])
            output['total'][key] = total
            output[key]['total'] = total
        return self.safe_balance(output)

    def fetch_orders(self, symbol=None, since=None, limit=None, params={}):
        """
        fetches a list of all orders(either open or closed/canceled) made by the user
        :param str|None symbol: unified market symbol of the market orders were made in
        :param int|None since: the earliest time in ms to fetch orders for
        :param int|None limit: the maximum number of  orde structures to retrieve
        :param dict params: extra parameters specific to the deepwaters api endpoint
        :returns [dict]: a list of `order structures <https://docs.ccxt.com/en/latest/manual.html#order-structure>`
        """
        self.load_markets()
        self.load_nonce()
        request = {}
        if symbol is not None:
            market = self.market(symbol)
            request['pair'] = market['id']
        if since is not None:
            # TRUNCATE, self.markets[symbol]['precision']['quote'], self.precisionMode, self.paddingMode
            since = Precise.string_mul(since, '1000')
            request['created-at-or-after-micros'] = since
        if limit is not None:
            limit = self.decimal_to_precision(limit, TRUNCATE, 4)
            request['limit'] = limit
        response = self.privateGetOrders(self.extend(request, params))
        success = self.safe_value(response, 'success', False)
        # [
        #     {
        #       "averagePrice": "string",
        #       "baseAssetID": "string",
        #       "createdAtMicros": 0,
        #       "customerObjectID": "string",
        #       "durationType": "GOOD_TILL_CANCEL",
        #       "expiresAtMicros": 0,
        #       "modifiedAtMicros": 0,
        #       "originalQuantity": "string",
        #       "price": "string",
        #       "quantity": "string",
        #       "quoteAssetID": "string",
        #       "side": "BUY",
        #       "status": "ACTIVE",
        #       "type": "LIMIT",
        #       "venueOrderID": "string",
        #       "volume": "string"
        #     }
        #   ]
        if not success:
            return self.handle_error(response)
        result = self.safe_value(response, 'result', {})
        orders = self.safe_value(result, 'orders', [])
        return self.parse_orders(orders)

    def fetch_my_trades(self, symbol=None, since=None, limit=None, params={}):
        """
        fetch all trades made by the user
        :param str symbol: unified market symbol
        :param int|None since: the earliest time in ms to fetch trades for
        :param int|None limit: the maximum number of trades structures to retrieve
        :param dict params: extra parameters specific to the deepwaters api endpoint
        :returns [dict]: a list of `trade structures <https://docs.ccxt.com/en/latest/manual.html#trade-structure>`
        """
        self.load_markets()
        request = {
            # 'pair': '',
            # 'type': '',
            # 'created-at-or-after-micros': '',
            # 'created-before-micros': '',
            # 'skip': '',
            # 'limit': ''
        }
        if symbol is not None:
            market = self.market(symbol)
            request['pair'] = market['id']
        if since is not None:
            since = Precise.string_mul(since, '1000')
            request['created-at-or-after-micros'] = since
        if limit is not None:
            limit = self.decimal_to_precision(limit, TRUNCATE, 4)
            request['limit'] = limit
        response = self.privateGetTrades(self.extend(request, params))
        success = self.safe_value(response, 'success', False)
        if not success:
            return self.handle_error(response)
        result = self.safe_value(response, 'result', {})
        trades = self.safe_value(result, 'trades', [])
        output = []
        for i in range(0, len(trades)):
            # {
            #     "aggressorCustomerObjectID": "string",
            #     "aggressorFeesTotalValueInQuoteAsset": "string",
            #     "aggressorFeesQuoteAssetAmount": "string",
            #     "aggressorFeesWTRAmount": "string",
            #     "aggressorRemainingQuantity": "string",
            #     "aggressorVenueOrderID": "string",
            #     "baseAssetID": "string",
            #     "createdAtMicros": 0,
            #     "makerCustomerObjectID": "string",
            #     "makerFeesTotalValueInQuoteAsset": "string",
            #     "makerFeesQuoteAssetAmount": "string",
            #     "makerFeesWTRAmount": "string",
            #     "makerRemainingQuantity": "string",
            #     "makerVenueOrderID": "string",
            #     "makerWasBuyer": True,
            #     "price": "string",
            #     "quantity": "string",
            #     "quoteAssetID": "string",
            #     "tradeID": "string",
            #     "tradeType": "FILL",
            #     "userWasAggressor": True,
            #     "userWasMaker": True
            # }
            trade = trades[i]
            id = self.safe_value(trade, 'tradeID')
            createdAtMicros = self.safe_value(trade, 'createdAtMicros')
            timestamp = self.parse_number(Precise.string_div(createdAtMicros, '1000', 0))
            datetime = self.iso8601(timestamp)
            baseAssetID = self.safe_value(trade, 'baseAssetID')
            quoteAssetID = self.safe_value(trade, 'quoteAssetID')
            market = self.market(baseAssetID + '-' + quoteAssetID)
            symbol = self.safe_value(market, 'symbol')
            makerWasBuyer = self.safe_value(market, 'makerWasBuyer')
            userWasMaker = self.safe_value(market, 'userWasMaker')
            maker = 'maker' if userWasMaker else 'taker'
            side = userWasMaker == 'buy' if makerWasBuyer else 'sell'
            price = self.safe_number(market, 'price')
            amount = self.safe_number(market, 'quantity')
            cost = Precise.string_mul(self.safe_value(market, 'price'), self.safe_value(market, 'quantity'))
            userWasAggressor = self.safe_value(market, 'userWasAggressor')
            type = 'market' if userWasAggressor else 'limit'
            output.append(self.safe_trade({
                'info': trade,
                'id': id,
                'timestamp': timestamp,
                'datetime': datetime,
                'symbol': symbol,
                'order': None,
                'type': type,
                'side': side,
                'takerOrMaker': maker,
                'price': price,
                'amount': amount,
                'cost': cost,
            }))
        return output

    def fetch_open_orders(self, symbol=None, since=None, limit=None, params={}):
        """
        fetch all unfilled currently open orders
        :param str|None symbol: unified market symbol
        :param int|None since: the earliest time in ms to fetch open orders for
        :param int|None limit: the maximum number of  open orders structures to retrieve
        :param dict params: extra parameters specific to the deepwaters api endpoint
        :returns [dict]: a list of `order structures <https://docs.ccxt.com/en/latest/manual.html#order-structure>`
        """
        paramsWithFilters = self.extend(params, {'status-in': 'ACTIVE-PARTIALLY_FILLED'})
        # [
        #     {
        #       "averagePrice": "string",
        #       "baseAssetID": "string",
        #       "createdAtMicros": 0,
        #       "customerObjectID": "string",
        #       "durationType": "GOOD_TILL_CANCEL",
        #       "expiresAtMicros": 0,
        #       "modifiedAtMicros": 0,
        #       "originalQuantity": "string",
        #       "price": "string",
        #       "quantity": "string",
        #       "quoteAssetID": "string",
        #       "side": "BUY",
        #       "status": "ACTIVE-PARTIALLY_FILLED",
        #       "type": "LIMIT",
        #       "venueOrderID": "string",
        #       "volume": "string"
        #     }
        #   ]
        return self.fetch_orders(symbol, since, limit, paramsWithFilters)

    def fetch_closed_orders(self, symbol=None, since=None, limit=None, params={}):
        """
        fetches information on multiple closed orders made by the user
        :param str|None symbol: unified market symbol of the market orders were made in
        :param int|None since: the earliest time in ms to fetch orders for
        :param int|None limit: the maximum number of  orde structures to retrieve
        :param dict params: extra parameters specific to the deepwaters api endpoint
        :returns [dict]: a list of `order structures <https://docs.ccxt.com/en/latest/manual.html#order-structure>`
        """
        paramsWithFilters = self.extend(params, {'status-in': 'FILLED'})
        # [
        #     {
        #       "averagePrice": "string",
        #       "baseAssetID": "string",
        #       "createdAtMicros": 0,
        #       "customerObjectID": "string",
        #       "durationType": "GOOD_TILL_CANCEL",
        #       "expiresAtMicros": 0,
        #       "modifiedAtMicros": 0,
        #       "originalQuantity": "string",
        #       "price": "string",
        #       "quantity": "string",
        #       "quoteAssetID": "string",
        #       "side": "BUY",
        #       "status": "FILLED",
        #       "type": "LIMIT",
        #       "venueOrderID": "string",
        #       "volume": "string"
        #     }
        #   ]
        return self.fetch_orders(symbol, since, limit, paramsWithFilters)

    def fetch_canceled_orders(self, symbol=None, since=None, limit=None, params={}):
        paramsWithFilters = self.extend(params, {'status-in': 'CANCELLED'})
        # [
        #     {
        #       "averagePrice": "string",
        #       "baseAssetID": "string",
        #       "createdAtMicros": 0,
        #       "customerObjectID": "string",
        #       "durationType": "GOOD_TILL_CANCEL",
        #       "expiresAtMicros": 0,
        #       "modifiedAtMicros": 0,
        #       "originalQuantity": "string",
        #       "price": "string",
        #       "quantity": "string",
        #       "quoteAssetID": "string",
        #       "side": "BUY",
        #       "status": "CANCELLED",
        #       "type": "LIMIT",
        #       "venueOrderID": "string",
        #       "volume": "string"
        #     }
        #   ]
        return self.fetch_orders(symbol, since, limit, paramsWithFilters)

    def create_order(self, symbol, type, side, amount, price=None, params={}):
        """
        create an order
        :param str symbol: unified symbol of the market to create an order in
        :param str type: 'market' or 'limit'
        :param str side: 'buy' or 'sell'
        :param float amount: how much of currency you want to trade in units of base currency
        :param float|None price: the price at which the order is to be fullfilled, in units of the quote currency, ignored in market orders
        :param dict params: extra parameters specific to the deepwaters api endpoint
        :returns dict: an `order structure <https://docs.ccxt.com/en/latest/manual.html#order-structure>`
        """
        self.load_markets()
        durationType = self.safe_string(params, 'durationType', 'GOOD_TILL_CANCEL')
        orderType = type.upper()
        market = self.market(symbol)
        orderSide = side.upper()
        customerObjectId = self.safe_string(params, 'customerObjectId')
        expiresAtMicros = self.safe_number(params, 'expiresAtMicros', 0)
        expiresIn = self.safe_value(params, 'expiresIn', '')
        precisionQuantity = self.amount_to_precision(symbol, amount)
        # {
        #     "baseAssetID": "string",
        #     "customerObjectID": "string",
        #     "durationType": "GOOD_TILL_CANCEL",
        #     "expiresAtMicros": 0,
        #     "expiresIn": "string",
        #     "price": "string",
        #     "quantity": "string",
        #     "quoteAssetID": "string",
        #     "side": "BUY",
        #     "type": "LIMIT"
        #   }
        request = {
            'baseAssetID': market['baseId'],
            'durationType': durationType,
            'customerObjectID': customerObjectId,
            'type': orderType,
            'side': orderSide,
            'quoteAssetID': market['quoteId'],
            'quantity': precisionQuantity,
        }
        if type == 'limit':
            precisionPrice = self.price_to_precision(symbol, price)
            request['price'] = precisionPrice
            if durationType == 'GOOD_TILL_EXPIRY':
                request['expiresIn'] = expiresIn if expiresIn else None
                request['expiresAtMicros'] = expiresAtMicros if expiresAtMicros else null
        self.load_nonce()
        response = self.privatePostOrders(request)
        success = self.safe_value(response, 'success', False)
        if not success:
            return self.handle_error(response)
        # Market Order
        # {
        #     status: 'FILLED',
        #     respondedAtMicros: '1677872186295635',
        #     venueOrderID: '0x85b3e1dd0c9f4609a3b611f991c54c51d85ab510745b11a039af52c0bab46b1a',
        #     originalQuantity: '1.00',
        #     quantity: '0.00'
        # }
        # Limit Order
        result = self.safe_value(response, 'result', {})
        id = self.safe_value(result, 'venueOrderID')
        respondedAtMicros = self.safe_value(result, 'respondedAtMicros')
        timestamp = self.parse_number(Precise.string_div(respondedAtMicros, '1000', 0))
        datetime = self.iso8601(timestamp)
        exchangeStatus = self.safe_value(result, 'status')
        status = self.parse_order_status(exchangeStatus)
        originalQuantitiy = self.safe_value(result, 'originalQuantitiy')
        order = {
            'id': id,
            'timestamp': timestamp,
            'datetime': datetime,
            'status': status,
            'symbol': symbol,
            'type': type,
            'side': side,
            'amount': originalQuantitiy,
            'info': result,
        }
        if exchangeStatus == 'FILLED':
            order['filled'] = originalQuantitiy
        if type == 'limit':
            order['price'] = price
        return self.safe_order(order)

    def fetch_order(self, id, symbol=None, params={}):
        # params and symbol are unused
        self.load_markets()
        self.load_nonce()
        if not isinstance(id, str):
            raise ArgumentsRequired(self.id + ' fetchOrder() requires a string id')
        isVenueId = id[0:2] == '0x'
        response = None
        request = {
            'id': id,
        }
        if isVenueId:
            response = self.privateGetOrdersByVenueOrderIdId(self.extend(request, params))
        else:
            response = self.privateGetOrdersByCustomerObjectIdId(self.extend(request, params))
        success = self.safe_value(response, 'success', False)
        if not success:
            return self.handle_error(response)
        result = self.safe_value(response, 'result', {})
        # {
        #     "averagePrice": "string",
        #     "baseAssetID": "string",
        #     "createdAtMicros": 0,
        #     "customerObjectID": "string",
        #     "durationType": "GOOD_TILL_CANCEL",
        #     "expiresAtMicros": 0,
        #     "modifiedAtMicros": 0,
        #     "originalQuantity": "string",
        #     "price": "string",
        #     "quantity": "string",
        #     "quoteAssetID": "string",
        #     "side": "BUY",
        #     "status": "ACTIVE",
        #     "type": "LIMIT",
        #     "venueOrderID": "string",
        #     "volume": "string"
        #   }
        return self.parse_order(result)

    def cancel_order(self, id, symbol=None, params={}):
        """
        cancels an open order
        :param str id: order id
        :param str symbol: unused
        :param dict params: unused
        :returns dict: An `order structure <https://docs.ccxt.com/en/latest/manual.html#order-structure>`
        """
        self.load_markets()
        self.load_nonce()
        params = {
            'id': id,
        }
        if not isinstance(id, str):
            raise ArgumentsRequired(self.id + ' cancelOrder() requires a string id')
        isVenueId = id[0:2] == '0x'
        response = None
        if isVenueId:
            # "results": [
            #     {
            #       "customerObjectID": "string",
            #       "error": "string",
            #       "respondedAtMicros": 0,
            #       "status": "ACTIVE",
            #       "success": True,
            #       "venueOrderID": "string"
            #     }
            #   ]
            response = self.privateDeleteOrdersByVenueOrderIdId(params)
        else:
            # "results": [
            #     {
            #       "customerObjectID": "string",
            #       "error": "string",
            #       "respondedAtMicros": 0,
            #       "status": "ACTIVE",
            #       "success": True,
            #       "venueOrderID": "string"
            #     }
            #   ]
            response = self.privateDeleteOrdersByCustomerObjectIdId(params)
        success = self.safe_value(response, 'success', False)
        if not success:
            return self.handle_error(response)
        result = self.safe_value(response, 'result')
        respondedAtMicros = self.safe_value(result, 'respondedAtMicros')
        timestamp = self.parse_number(Precise.string_div(respondedAtMicros, '1000', 0))
        datetime = self.iso8601(timestamp)
        order = {
            'status': 'canceled',
            'id': id,
            'datetime': datetime,
            'timestamp': timestamp,
            'symbol': symbol,
            'info': result,
        }
        return self.safe_order(order)

    def cancel_all_orders(self, symbol=None, params={}):
        self.load_markets()
        self.load_nonce()
        if symbol:
            market = self.market(symbol)
            pairParam = {
                'pair': market.id,
            }
            params = self.extend(params, pairParam)
        response = self.privateDeleteOrders(params)
        # EXAMPLE response
        # {
        #     "result": {
        #       "numCancelled": 0,
        #       "respondedAtMicros": 0
        #     },
        #     "success": True
        #   }
        success = self.safe_value(response, 'success', False)
        if not success:
            return self.handle_error(response)
        return self.safe_value(response, 'result', {})

    def sign(self, path, api='public', method='GET', params={}, headers=None, body=None):
        """
        Signs an api request to deepwaters exchange
        see https://rest.docs.api.deepwaters.xyz/cutting_edge/index.html
        """
        # Get array of params from the path
        pathParams = self.extract_params(path)
        # self is the path with any variable segments substituted from provided params
        # currently only relevant for 'pairs/{marketId}/orderbook', which isn't signed
        path = '/' + self.implode_params(path, params)
        # Remove params which were substituted in path, required for signing
        params = self.omit(params, pathParams)
        nonce = ''
        bodyString = ''
        if api == 'private':
            headers = {}
            timestamp = self.number_to_string(self.microseconds() + 10)
            self.check_required_credentials()
            if (method == 'GET') or (method == 'DELETE'):
                keys = list(params.keys())
                if len(keys):
                    path = path + '?' + self.urlencode(params)
            if (method == 'POST') or (method == 'DELETE'):
                if method == 'POST':
                    body = params
                    bodyString = json.dumps(body)
                nonce = self.number_to_string(self.get_nonce())
                postDeleteHeaders = {
                    'content-type': 'application/json',
                    'X-DW-NONCE': nonce,
                }
                headers = self.extend(headers, postDeleteHeaders)
            message = method + '/rest/v1' + path.lower() + timestamp + nonce + bodyString
            # calculate signature
            signature = self.sign_hash(self.hash(message, 'keccak'), self.secret)
            signature.v = signature.v - 27
            vByte = signature.v.toString(16)
            if len(vByte) == 1:
                vByte = '0' + vByte
            signatureString = signature.r + signature.s[2:] + vByte
            sigHeaders = {
                'X-DW-APIKEY': self.apiKey,
                'X-DW-TSUS': timestamp,
                'X-DW-SIGHEX': signatureString,
            }
            headers = self.extend(headers, sigHeaders)
        url = self.urls['api'][api] + path
        if len(bodyString):
            return {'url': url, 'method': method, 'body': bodyString, 'headers': headers}
        return {'url': url, 'method': method, 'body': body, 'headers': headers}

    def load_nonce(self):
        # nonce is needed for signing transactions but since the sign method
        # is not async, the  #loadNonce method should be called
        # by methods who must be signed with nonce beforehand
        response = self.privateGetCustomerApiKeyStatus()
        # "result": {
        #     "APIKey": "string",
        #     "createdAtMicros": 0,
        #     "expiresAtMicros": 0,
        #     "label": "string",
        #     "modifiedAtMicros": 0,
        #     "nonce": 0,
        #     "status": "string"
        #   },
        success = self.safe_value(response, 'success', False)
        if not success:
            return self.handle_error(response)
        result = self.safe_value(response, 'result', {})
        nonce = self.safe_string(result, 'nonce')
        if not nonce:
            raise InvalidNonce('Nonce could not be found')
        self.dwnonce = self.parse_number(nonce)

    def get_nonce(self):
        if not self.dwnonce:
            return 0
        return self.dwnonce

    def handle_error(self, response={}):
        error = self.safe_string(response, 'error', '')
        code = self.safe_string(response, 'code', '')
        status = self.safe_string(response, 'status', '')
        raise ExchangeError(code + ': ' + error + ' ' + status)

    def parse_order_status(self, status):
        statuses = {
            'ACTIVE': 'open',
            'FILLED': 'closed',
            'PARTIALLY_FILLED': 'open',
            'REJECTED': 'rejected',
            'CANCELLED': 'canceled',
            'EXPIRED': 'expired',
        }
        return self.safe_string(statuses, status, None)

    def parse_order(self, order, market=None):
        # {
        #     venueOrderID: '0x1a5f344dcfeae6fbf1949b3f79139e0618ca95964d7512d3e0cc4d0569b4aab8',
        #     type: 'LIMIT',
        #     side: 'SELL',
        #     status: 'FILLED',
        #     originalQuantity: '1.00',
        #     quantity: '0.00',
        #     baseAssetID: 'WAVAX.AVALANCHE_FUJI.43113.TESTNET.PROD',
        #     quoteAssetID: 'USDC.AVALANCHE_FUJI.43113.TESTNET.PROD',
        #     price: '16.5',
        #     averagePrice: '16.529',
        #     volume: '16.529',
        #     durationType: 'GOOD_TILL_CANCEL',
        #     createdAtMicros: '1677875410433286',
        #     modifiedAtMicros: '1677875410452713'
        # }
        id = self.safe_value(order, 'venueOrderID')
        type = self.safe_string_lower(order, 'type')
        side = self.safe_string_lower(order, 'side')
        exchangeStatus = self.safe_value(order, 'status')
        status = self.parse_order_status(exchangeStatus)
        createdAtMicros = self.safe_value(order, 'createdAtMicros')
        timestamp = self.parse_number(Precise.string_div(createdAtMicros, '1000', 0))
        datetime = self.iso8601(timestamp)
        modifiedAtMicros = self.safe_value(order, 'modifiedAtMicros')
        lastTradeTimestamp = self.parse_number(Precise.string_div(modifiedAtMicros, '1000', 0))
        baseAssetID = self.safe_value(order, 'baseAssetID')
        quoteAssetID = self.safe_value(order, 'quoteAssetID')
        market = market if market else self.market(baseAssetID + '-' + quoteAssetID)
        symbol = self.safe_value(market, 'symbol')
        price = self.safe_number(order, 'price')
        average = self.safe_number(order, 'averagePrice')
        amount = self.safe_number(order, 'originalQuantity')
        filled = Precise.string_sub(self.safe_value(order, 'originalQuantity'), self.safe_value(order, 'quantity'))
        remaining = Precise.string_sub(self.safe_value(order, 'originalQuantity'), filled)
        cost = Precise.string_mul(self.safe_value(order, 'price'), filled)
        output = {
            'id': id,
            'status': status,
            'timestamp': timestamp,
            'datetime': datetime,
            'lastTradeTimestamp': lastTradeTimestamp,
            'symbol': symbol,
            'type': type,
            'side': side,
            'price': price,
            'average': average,
            'amount': amount,
            'filled': filled,
            'remaining': remaining,
            'cost': cost,
            'info': order,
        }
        return self.safe_order(output)

    def fetch_time(self, params={}):
        """
        fetches the current integer timestamp in milliseconds from the deepwaters server
        :param dict params: extra parameters specific to the deepwaters api endpoint
        :returns int: the current integer timestamp in milliseconds from the deepwaters server
        """
        response = self.publicGetTime()
        success = self.safe_value(response, 'success', False)
        if not success:
            return self.handle_error(response)
        timestampMicros = self.safe_value(response, 'timestampMicros')
        timestamp = self.parse_number(Precise.string_div(timestampMicros, '1000', 0))
        return timestamp
